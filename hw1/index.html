<html>

<head>
	<title>CS184 Homework 1 Writeup</title>
</head>

<body>
	<h1>CS184 Homework 1 Writeup</h1>
	<h2>Task 1: Drawing Single-Color Triangles</h2>
	<h3>Walk through how you rasterize triangles in your own words.</h3>
	<p>First, by using the minimum and maximum coordinates given in the 3 points, a bounding box of the triangle is
		drawn. We then ran the isCounterClockwise() function to check if the triangle is wound Clockwise or
		CounterClockwise.
		If the triangle is wound Clockwise, we swap two of the points so that CounterClockwise winding is attained. This
		ensures that the 3 points of the triangle are ordered such that they follow the right hand rule.</p>
	<p>For every pixel in the bounding box, it runs through a helper function named inside(), which determines if the
		pixel is inside the triangle using the three point-in-triangle tests. If it is inside the boundary, the
		fill_pixel()
		function is called, and the pixel is coloured in the rendered image. To ensure that a sample on the boundary of
		the triangle is drawn, the check for whether to call fill_pixel() includes occasions where the sample lies on
		the
		boundary (checking for >= instead of just >).</p>

	<h3>Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.
	</h3>
	<p>Given that I am checking each sample within the bounding box of the triangle, my algorithm would be of the same
		efficiency.</p>
	<h3>basic/test4.svg</h3>
	<img src="./media/task1/task1.png" style="width: 50%; height: auto;" />

	<h2>Task 2: Antialiasing by Supersampling</h2>
	<h3>Supersampling algorithm:</h3>
	<p>First, we increased sample_buffer size to = width*height*sample rate. This ensures that the sample_buffer is
		large enough to accommodate every subpixel that would be considered with supersampling. Then, we ran through
		every pixel in the bounding box. For every pixel, run through each sub-pixel and determine if it's inside the
		triangle using the inside() function. If it is, add it into the sample_buffer, assigning it with the
		corresponding color.</p>
	<p>After the sample_buffer is filled, resolve_to_framebuffer() is called. This function basically maps each pixel in
		the framebuffer to all its relevant subpixels in the sample_buffer. The average color of all the subpixels for
		that pixel is calculated, then added to the framebuffer.</p>
	<h3>Data structures:</h3>
	<p>Within the code, we declared a struct called Point, where
		Point = {
		float x, y;
		size_t index;};</p>

	<p>This allows us to populate the sample buffer easily using the index after the generation of sub-pixels (Point)
		for each pixel. This index also later helps us find the corresponding pixel that each of these sub-pixels belong
		to, so as to easily calculate the average color.</p>
	<h3>Rasterization pipeline modification:</h3>
	<p>As compared to task 1, which directly draws onto the framebuffer when it has found the correct color for each
		pixel, we modified the pipeline as follows:
	<ul>
		<li>When rasterize_triangle() is called, every color of the sub-pixels is drawn onto the sample buffer</li>
		<li>resolve_to_framebuffer() then translates the sample buffer to the frame buffer so the image is displayed
			with the average color of sub-pixels</li>
	</ul>

	</p>
	<h3>Supersampling to achieve antialiasing:</h3>
	<p>When we find the average color of each pixel using sub-pixels (number dependent on sample rate), each pixel at
		the edge of the shape is rendered as a color that lies between the two color boundaries. This creates a blurring
		effect at the edges, and causes the overall image to look smoother and more continuous, rather than pixelated
		and jaggy.
	</p>
	<h3>
		png screenshots of basic/test4.svg
	</h3>
	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/task2/rate1.png" alt="Description of Image 1" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Sample Rate = 1</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/task2/rate4.png" alt="Description of Image 2" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Sample Rate = 4</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/task2/rate16.png" alt="Description of Image 3" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Sample Rate = 16</figcaption>
		</figure>
	</div>
	<p>As the sample rate increases, it can be observed that the edges of the triangle become increasingly
		continuous,and less pixelated. This is because an increase in sample rate results in an increase in sub-pixels
		considered for each pixel, resulting in a more accurate average value of the boundary colors that each pixel
		represents. This causes the pixels to have a more continuous color gradient.
	</p>

	<h2>Task 3: Transforms</h2>
	<h3>myrobot.svg</h3>
	<img src="./media/task3/task3.png" style="width: 50%; height: auto;" />
	<p>In this svg, we were trying to make the robot do the signature robot pose with its arms. To achieve this, we
		first rotated the outer arms by 90 degrees, then changed the translation to (-50 20) and (50 -20) for the two
		arms.</p>


	<h2>Task 4: Barycentric Coordinates</h2>
	<h3>What barycentric coordinates are:</h3>
	<img src="./media/task4/triangle.png" style="width: 50%; height: auto;" />
	<p>Barycentric Coordinates linearly interpolate values at vertices, where a point in a triangle (defined by three
		vertices) can be represented as a mathematical expression representing the proportional distances from the
		vertices. This can be observed from the triangle image, the three vertices are colored green, yellow and red we
		can see that the points closer to the red vertex are mostly red due to the weight of the red vertex being larger
		than the other weights due to a closer proximity to the red vertex. The same is observed for the green and
		yellow vertices. In the center where pixels are almost equidistant from all vertices, the color observed is a
		blend between the three colors.</p>
	<h3>svg/basic/test7.svg with default viewing parameters and sample rate 1</h3>
	<img src="./media/task4/test7.png" style="width: 50%; height: auto;" />


	<h2>Task 5: "Pixel Sampling" for Texture Mapping</h2>
	<h3> Pixel sampling and how we implemented it to perform texture mapping
	</h3>
	<p>Pixel sampling involves using barycentric coordinates to map the relative distance between the points and the 3
		boundary coordinates in the sample and texture space relatively.</p>
	<p>Nearest neighbor: Use barycentric coordinates to find the corresponding coordinate in the texture space, and use
		the
		color of that coordinate.</p>
	<p>Bilinear neighbor: By using the relative distance of the coordinate to its 4 nearest neighbors in the texture
		map,
		compute two colors by using 2 linear interpolations in the horizontal space, then using the results to perform a
		vertical interpolation to get the final color.</p>
	<h3>Comparing bilinear sampling and nearest sampling</h3>
	<h4>Bilinear sampling</h4>
	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/task5/bilinear1.png" alt="Description of Image 2" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Sample Rate = 1</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/task5/bilinear16.png" alt="Description of Image 3" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Sample Rate = 16</figcaption>
		</figure>
	</div>
	<h4>Nearest pixel sampling</h4>
	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/task5/nearest1.png" alt="Description of Image 2" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Sample Rate = 1</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/task5/nearest16.png" alt="Description of Image 3" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Sample Rate = 16</figcaption>
		</figure>
	</div>
	<p>At both the 1 sample per pixel and the 16 samples per pixel screenshot, we can observe that the use of bilinear
		sampling achieves a better looking image as compared to the nearest sampling method. This would be due to the
		linear
		interpolation done in bilinear sampling, resulting in lower frequencies in the resultant signal as compared to
		nearest sampling, which can result in high frequency signals and hence a less smooth image.</p>

	<p>There will be a larger difference in the two methods at lower sampling rates (1 sample) as compared to higher
		sampling rates (16 samples). This is due to the supersampling algorithm that we already have in place. This
		means
		that both the nearest sampling and bilinear sampling have some form of existing interpolation and the linear
		interpolation from the bilinear sampling will be less evident.</p>



	<h2>Task 6: "Level Sampling" with Mipmaps for Texture Mapping</h2>
	<p>Explanation of level sampling using mipmaps for texture stretching, including computational details and
		trade-offs among speed, memory usage, and antialiasing power.</p>
</body>

</html>